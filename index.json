[{"categories":["Algorithm"],"content":"整數二分 ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:0:0","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":["Algorithm"],"content":"何時使用 有單調性（monotone)的一組數字可以二分，但沒有單調性也可以使用二分法 ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:0:1","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":["Algorithm"],"content":"在何時適用 若可以找到某種性質，在右半邊滿足，左半邊不滿足(在右半邊不滿足，左半邊滿足)，就可以尋找邊界 ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:0:2","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":["Algorithm"],"content":"模板code bool check(int x){/*stasify some conditions*/} // [l, r] -\u003e [l, mid] + [mid + 1, r] int bsearch1(int l, int r) { int mid = l + r \u003e\u003e 1; if(check(mid)) r = mid; else l = mid + 1; } // [l, r] -\u003e [l, mid - 1] + [mid, r] int bsearch2(int l, int r) { int mid = l + r + 1 \u003e\u003e 1; if(check(mid)) l = mid; else r = mid - 1; } return l; //also can return r ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:0:3","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":["Algorithm"],"content":"圖例與解釋 找尋紅色的邊界：check(mid) ：滿足紅色條件 mid = (l + r +1)/2 （上取整） if(check(mid)) true(mid在紅色區間內) 答案在： [mid, r] 更新 l = mid; false(mid在綠色區間內) 答案在：[l,mid-1] 更新 r = mid-1; +1的原因: 因為C++下取整（下高斯），所以若 l=r-1 -\u003e mid=(l+r)/2=l 因此在check(mid)==true時更新 l = mid會發生死循環。補上+1後，l = mid = r; l就能繼續更新 [l, r] -\u003e [r,r] 停止循環 找尋綠色的邊界點：check(mid) ：滿足綠色條件 mid = l + r /2 if(check(mid)) true(mid在綠色區間內) 答案在：[l, mid] 更新 r = mid; false(mid在紅色區間內) 答案在：[mid+1, r] 更新 l = mid+1; ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:0:4","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":["Algorithm"],"content":"思考方式 先寫出check函數，再根據條件，思考如何去更新區間 更新方式 [l, r] 更新成 [l, mid] + [mid + 1, r] 使用bseach1 [l, r] 更新成 [l, mid - 1] + [mid, r] 使用bseach2 ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:0:5","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":["Algorithm"],"content":"LeetCode 類題 ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:1:0","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":["Algorithm"],"content":"34. Find First and Last Position of Element in Sorted Array Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] SOL: class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { int n = nums.size(); if(!n) return {-1,-1}; vector\u003cint\u003e res(2, -1); int l = 0, r = n - 1; while(l \u003c r) { int mid = l + r \u003e\u003e 1; if(nums[mid] \u003e= target) r = mid; else l = mid + 1; /* 5, 7, 7, 8, 8, 10 -------- 滿足此區間 */ } if(nums[l] != target) return res; res[0] = l; l = 0, r = n - 1; while(l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if(nums[mid] \u003c= target) l = mid; else r = mid - 1; /* 5, 7, 7, 8, 8, 10 ---------- 滿足此區間 */ } res[1] = l; return res; } }; ","date":"2021-09-07","objectID":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/:1:1","tags":[],"title":"整數二分法 Binary Search","uri":"/2021-9-7-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"categories":null,"content":"About This website 主要是整理關於Linux \u0026 演算法的筆記 第一次開website，不敢講寫得有多好，但如果對別人有幫助那當然是最好 ","date":"2021-08-12","objectID":"/about/:1:0","tags":null,"title":"About Wandering World","uri":"/about/"},{"categories":null,"content":"Linux (更新中) Linux 用書是 The Linux Programming Interface 以及 Advanced Programming in the UNIX Environment 兩書互相參考之後整理出比較方便閱讀的筆記，加上本人自己的想法，當然有可能有小錯誤，建議有問題可以直接參考man page(最為準確) ","date":"2021-08-12","objectID":"/about/:1:1","tags":null,"title":"About Wandering World","uri":"/about/"},{"categories":null,"content":"Algorithm 演算法部分是在練習LEETCODE(MID HARD)以及ACM題目時，整理出的算法，主要內容為比較難以想像的算法(無法直觀地想到) 內容較雜，部分有附上CODE或是LEETCODE上的參考範例 ","date":"2021-08-12","objectID":"/about/:1:2","tags":null,"title":"About Wandering World","uri":"/about/"},{"categories":null,"content":"About Me 喜歡在Linux的環境上開發，包含維運、thread、multiple process開發 90年代的有點老（？的程式開發員，喜歡看很簡潔的code，研讀國外大神的code ","date":"2021-08-12","objectID":"/about/:2:0","tags":null,"title":"About Wandering World","uri":"/about/"},{"categories":null,"content":"Language C socket programming C++ ACM LEETCODE JAVA(可看懂，少寫) NODEJS 組合語言 PIC-18 verilog Matlab Python ","date":"2021-08-12","objectID":"/about/:2:1","tags":null,"title":"About Wandering World","uri":"/about/"},{"categories":["Algorithm"],"content":"KMP 基本概念 一種用來字符串匹配的算法 一些定義： s[] 為主字串 ， p[] 是匹配串 ， 即可以理解成\u0008p是否是s的子字串 前綴：包含首位字符但不包含末位字符的子字串; 後綴：包含末位字符但不包含首位字符的子字串 部分匹配值 ： 前綴與後綴最長共有長度 next[] 存的是每個下標對應的部分匹配值 核心思考：每次匹配失敗時，把p串往後移動至next對應的值 ","date":"2021-07-13","objectID":"/2021-07-13-kmp%E7%AE%97%E6%B3%95/:1:0","tags":[],"title":"KMP算法 -- next解釋","uri":"/2021-07-13-kmp%E7%AE%97%E6%B3%95/"},{"categories":["Algorithm"],"content":"next的含義與模擬 字串從1開始存，next[i], 是\u0008p[1,i]中前綴和後綴相同的最大長度（部分匹配值）， 定義 next[1] = 0 例如： idx 1 2 3 4 5 6 str a b c a b a next 0 0 0 1 2 1 求next陣列的code // m 為 p 的長度 for(int i = 2, j = 0; i \u003c= m; i++) { while(j \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; //已經有部分匹配值後，且匹配失敗，回退到上一個 if(p[i] == p[j + 1]) j++; ne[i] = j; // j為要回退的位置 } 匹配過程： for(int i = 1, j = 0; i \u003c n; i ++) { while(j \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j++; if(j == m) { //匹配成功 j = ne[j]; // 繼續匹配下一個字串 } } ","date":"2021-07-13","objectID":"/2021-07-13-kmp%E7%AE%97%E6%B3%95/:2:0","tags":[],"title":"KMP算法 -- next解釋","uri":"/2021-07-13-kmp%E7%AE%97%E6%B3%95/"},{"categories":["Linux"],"content":"CreateProcess ","date":"2021-06-20","objectID":"/2021-06-20-linux_chapter_24_createprocess/:0:0","tags":[],"title":"Linux Chapter 24 CreateProcess","uri":"/2021-06-20-linux_chapter_24_createprocess/"},{"categories":["Linux"],"content":"fork() exit() wait() execev() 簡介 fork() parent process經由呼叫fork()建立一個 child process child獲得parent的stack segment、data segment、heap segment、text segment 可說是把parent process一分為二 exit() terminate a process 將佔用的所有資源歸還給kernel parent 可以利用 wait()來取得結束的狀態(status) wait() 若child process還未呼叫exit()，那wait()會suspend parent process，直到有任一child process terminated 可以取得status execve() Load a new program到目前process的記憶體 丟去現存的text segment 重新建立 stack segment、data segment、heap segment 大致流程圖 ","date":"2021-06-20","objectID":"/2021-06-20-linux_chapter_24_createprocess/:1:0","tags":[],"title":"Linux Chapter 24 CreateProcess","uri":"/2021-06-20-linux_chapter_24_createprocess/"},{"categories":["Linux"],"content":"fork() #include \u003cunistd.h\u003epid_t fork(void); In parent: returns process ID of child on success, or –1 on error; in successfully created child: always returns 0 ","date":"2021-06-20","objectID":"/2021-06-20-linux_chapter_24_createprocess/:2:0","tags":[],"title":"Linux Chapter 24 CreateProcess","uri":"/2021-06-20-linux_chapter_24_createprocess/"},{"categories":["Algorithm"],"content":"Backpack 0 - 1 Problem 主問題：從n個物品選一些物品，在不超過最大容量下，使得價值最大。 解空間：{x1,x2….,xn} xi : 0 or 1 (表示取或不取) 共有 $2^n$ 可能的解 限制條件： $\\sum_{i=1}^n$ $w_ix_i$ \u003c= W 採用回溯法 限界條件： 對於任何一個中間節點z，從root到z的分支所代表的狀態已經確定，從z到子孫的節點還未確定。如果z在第t層，說明第1種物品到t-1種物品（是否裝入背包）確定，t可以沿著分支擴展確認狀態，t+1到n不確定。 目前裝入背包的物品總價用cp表示，因為還不確定t+1到n物品的狀態，先假設全部都放入背包，也就是剩餘的總價值，用rp表示。 cp + rp是所有從root出發經過中間節點z的可行解的價值上界。如果價值上界小於或等於目前的最優值，則說明節點z沒有繼續搜尋的必要 即 cp + rp \u003e bestp ","date":"2021-06-10","objectID":"/2021-06-11-backpack-problem/:0:0","tags":[],"title":"Backpack_Problem","uri":"/2021-06-11-backpack-problem/"},{"categories":["Algorithm"],"content":"solution 假設有4個物品，每個物品w [2,5,4,2], 價值v [6,3,5,4], W = 10 初始化：sumw , sumv 統計所有物品的總重和總價 -\u003e sumw = 13, sumw = 18,目前放入背包的物品重量cw = 0, 總價cp = 0, 最優值 bestp = 0 第一層：t = 1, 判斷cw + w[1] = 2 \u003c W （滿足限制條件）向左擴展分支，令x[1] = 1, cw = cw + w[1] = 2, cp = cp+v[1] = 6，生成2好節點 ….以此類推 到t = 3, cw + w[3] = 11 \u003e W, 因此不能放入，要判斷bound(t+1) \u003c是否需要剪枝\u003e rp(剩餘價值) = 4, cp + rp = 13 \u003e bestp, 所以擴展右子樹，生成4號節點 …. t = 5 ， t \u003e n ，表示已經擴展到最底部（沒有物品了），5號擴展完畢，bestx[]保存目前的最優解 回溯到4號節點，回溯需要 cw = cw - w[4] = 7, cp = cp - v[4] = 9，因為4號右邊子樹沒生成過，先判斷bound(t+1) 是否大於bestp，若無則繼續回溯，4號擴展完畢，回到3號，發現都左右考察過，再次回溯到2號。 2號右子樹沒有考察過，bound(3) \u003e bestp，擴展右邊，x[2] = 0，生成6號節點 …..往下看圖解 參考\u003c趣學演算法\u003e ","date":"2021-06-10","objectID":"/2021-06-11-backpack-problem/:1:0","tags":[],"title":"Backpack_Problem","uri":"/2021-06-11-backpack-problem/"},{"categories":["Algorithm"],"content":"Code 實現function。參數可依照習慣新增或減少，或是變數用全域宣告 ","date":"2021-06-10","objectID":"/2021-06-11-backpack-problem/:2:0","tags":[],"title":"Backpack_Problem","uri":"/2021-06-11-backpack-problem/"},{"categories":["Algorithm"],"content":"bound() double Bound(int i) { int rp = 0; while(i \u003c= n) // n goods { rp += v[i]; i ++; } return cp + rp; } ","date":"2021-06-10","objectID":"/2021-06-11-backpack-problem/:3:0","tags":[],"title":"Backpack_Problem","uri":"/2021-06-11-backpack-problem/"},{"categories":["Algorithm"],"content":"Backtrack void Backtrack(int t) { if(t \u003e n) { for(int j = 1; j \u003c= n; j++) bestx[j] = x[j]; bestp = cp; return; } if(cw + w[t] \u003c= W) // search left subtree { x[t] = 1; cw += w[t]; cp += v[t]; Backtrack(t+1); cw -= w[t]; cp -= v[t]; } if(Bound(t+1) \u003e bestp) // search right subtree { x[t] = 0; Backtrack(t + 1); } } ","date":"2021-06-10","objectID":"/2021-06-11-backpack-problem/:4:0","tags":[],"title":"Backpack_Problem","uri":"/2021-06-11-backpack-problem/"},{"categories":["Linux"],"content":"Linux Chapter 21 Signal 處理常式 ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:0:0","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"訊號處理常式設計 設定一個全域flag，接著離開。主程式會週期性的檢測此flag，若有被設定為flag，會進行適當的反應 會做出幾種類型的清理動作，接著結束行程或使用非區域跳躍（nonlocal goto）解開unwind the stack，並將控制權交回給主程式（是先定義的位置） ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:1:0","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"可重入函式與非同步訊號安全函式 可重入與不可重入 訊號處理常式與multiple thread的概念有關，前者可能會在任意時間點非同步的中斷程式執行，所以主程式與訊號處理常式會變成在同一個行程中，2個獨立的thread(非同步執行) 若函式可以在同一個行程的各thread中同步且安全的執行，此函式稱為是可重入的（reentrant） SUSv3對可重入的定義是: 當兩條或多條thread呼叫函式時，即便是彼此互相交叉執行，也能保證效果與各thread以未定義順序呼叫時一致 若函式會更新全域或靜態的資料結構，可能就是不可重入的函式（只使用local變數的函式保證是可重入）。 可能發生的情況： 若主程式在呼叫malloc()期間，受到一個同樣呼叫malloc()的訊號處理常式中斷，則此linklist可能會遭到破壞，因此malloc()的函式家族與使用這些函式的其他函式庫函式都是不可重入。 其他會傳回靜態配置的記憶體，也是不可重入的，crypt() getpwnam() gethostbyname() getservbyname() 函式的內部紀錄是使用靜態的資料結構也是不可重入的，例如scanf() printf()，他們會有緩衝的I/O更新內部資料結構，所以在訊號處理常式使用printf()也在主程式呼叫printf()，緩衝區的資料會交錯，導致得到非期望的輸出結果，甚至是整個程式crush 標準的非同步訊號安全函式（async-signal-safe functions） 指可以安全地從訊號處理常式進行呼叫。 當函式是reentrant函式，或是不會受到訊號處理常式中斷，可以稱函式為async-signal-safe function man page: https://man7.org/linux/man-pages//man7/signal-safety.7.html 在訊號處理常式內使用errno 因為可能會更新errno變數，會導致函式reentrant，因為可能會覆寫主程式之前呼叫函式設定的errno值。 所以可以先儲存errno的值，並在函式執行完畢之後，回存errno void handler(int sig) { int sErrno; sErrno = errno; /* can execute a function that might modify errno */ errno = sErron; } ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:1:1","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"全域變數與sig_atomic_t資料型別 全域變數有reetrant問題，但有時需要在主程式與訊號處理常式之間共用全域變數，要能正確處理即可以保證安全。 常見的設計是： 設定全域旗標，主程式會定期檢查，並採取動作來對收到的訊號做出反應（並且清除旗標），用此方式存取全域變數時，需要使用volatile來宣告，避免編譯器進行優化，而讓變數存在register。 可以宣告成： volatile sig_atomic_t flag，其中sig_atomic_t 可以保證原子操作。 C語言中的++ -- 不在sig_atomic_t 的範圍，要避免使用 在實作時要定義SIG_ATOMIC_MIN 、 SIG_ATOMIC_MAX，有號值域：-127 ~ 127、無號值域：0 ~ 255 ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:1:2","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"終止訊號處理常式的其他方法 先前提到的訊號處理常式在完成後通常是傳回主程式，有時候也需要一些其他的處理，例如： 使用_exit()終止行程，處理常式先進行一些清理的動作，（不使用exit()是因為他是非安全函式) 使用kill() 、 raise()送出訊號，以刪除行程 從訊號處理常式執行nonlocal跳轉 使用abort()終止，並core dump ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:2:0","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"Nonlocal 跳轉 可以利用setjmp() longjmp()進行跳轉，可以在收到硬體異常訊號時進行回復，並且可以catch訊號，同時可以將控制權傳回程式的特定位置， 例如：收到SIGINT，shell會執行nonlocal跳轉使得可以跳回主輸入迴圈中，以便讀取新的輸入。 進入訊號處理函式時，核心會自動將觸發的訊號以及在act.sa_mask欄位指定的每個訊號都加到行程的signal mask，並在正常返回時，將訊號從mask中解除。 因此若使用標準的longjmp()離開常式，在某些平台，不會將阻塞的訊號解除。 所以在POSIX.1-1990中，另外定義了新的函式 #include\u003csetjmp.h\u003eint sigsetjmp(sigjmp_buf env, int savesigs); Return 0 on initial call, nonzero on return via siglongjmp() void siglongjmp(sigjmp_buf env, int val); 若savesigs設定為nonzero，則呼叫sigsetjmp()時，行程目前signal mask會存在env中，之後可將env傳給siglongjmp進行還原，若設定為0，則不會儲存。 兩個函式都不是非同步訊號安全函式 若訊號處理常式中斷的主程式正在更新資料結構，而訊號處理常式再進行nonlocal跳轉結束，使得主程式未完成更新，可以使用sigprocmask()避免此問題，暫時將訊號堵塞。 ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:2:1","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"abort() 終止行程，並core dump #include\u003cstdlib.h\u003evoid abort(void); 產生SIGABRT來終止行程 無論阻塞或者忽略SIGABRT訊號，abort()不受影響，除非行程catch到SIGABRT訊號後handler未返回，否則abort()必須終止行程 若成功終止，還會刷新stdio stream並關閉 使用nonlocal跳轉可以抵消abort()的效果 ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:2:2","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"替代堆疊中處理訊號：sigaltstack() 呼叫訊號處理常式，核心會在行程stack中為其建立frame，若stack超過大小限制時，則無法為處理常式新增frame，因此不會被呼叫。 會有以下的做法： 配置一塊替代訊號堆疊的記憶體區域，作為訊號處理常式的frame 呼叫sigaltstack()，以通知核心替代訊號堆疊的存在 在建立訊號處理常式時，指定SA_ONSTACK旗標，通知核心在替代堆疊上建立frame #include\u003csignal.h\u003eint sigaltstack(const stack_t *sigstack, stack_t *old_sigstack); Return 0 on success, or -1 on error sigstack指向新替代訊號堆疊的位置與屬性 old_sigstack指向上一替代訊號堆疊的位置與屬性 指向的stack_t如下 To establish a new alternate signal stack, the fields of this structure are set as follows: man page: sigaltstack(2) ss.ss_flags This field contains either 0, or the following flag: SS_AUTODISARM (since Linux 4.7) Clear the alternate signal stack settings on entry to the signal handler. When the signal handler returns, the previous alternate signal stack settings are restored. This flag was added in order make it safe to switch away from the signal handler with swapcontext(3). Without this flag, a subsequently handled signal will corrupt the state of the switched-away signal handler. On kernels where this flag is not supported, sigaltstack() fails with the error EINVAL when this flag is supplied. ss.ss_sp This field specifies the starting address of the stack. When a signal handler is invoked on the alternate stack, the kernel automatically aligns the address given in ss.ss_sp to a suitable address boundary for the underlying hardware architecture. ss.ss_size This field specifies the size of the stack. The constant SIGSTKSZ is defined to be large enough to cover the usual size requirements for an alternate signal stack, and the constant MINSIGSTKSZ defines the minimum size required to execute a signal handler. typedef struct{ void *ss_sp; /* Starting address of alternate stack */ int ss_flags; /* Flags: SS_ONSTACK, SS_DISABLE */ size_t ss_size; /* Size of alternate stack */ } ss_sp ss_size 指定了位置和大小 ss_flag包含 SS_ONSTACK The process is currently executing on the alternate signal stack. Attempts to modify the alternate signal stack while the process is executing on it fail. This flag shall not be modified by processes. SS_DISABLE The alternate signal stack is currently disabled. ","date":"2021-06-02","objectID":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/:3:0","tags":[],"title":"Linux Chapter 21 Signal 處理常式","uri":"/2021-06-02-linux_chapter_21_signal%E8%99%95%E7%90%86%E5%B8%B8%E5%BC%8F/"},{"categories":["Linux"],"content":"Linux Chapter 20 Signal 基本概念 ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:0:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"概念 signal 可以通知行程（process）有事件發生，也可以稱為軟體中斷，多數情況下都無法預測訊號抵達的時間。 行程可以送出訊號給另外一個行程，在此可以做為synchronization 或者 IPC 的技術。 ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"訊號類型與預設行為 可以在signal(7)使用手冊列出訊號名稱，或是參考書上p.430 下圖列出簡易版訊號表： ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"改變訊號處置 Unix系統提供兩種 1.signal() 2. sigaction() signal()提供設定訊號的原始API 介面比sigaction()簡單 sigaction()是建立訊號處置常式首推的API signal() 是基於 sigaction()實作的函式 #include\u003csignal.h\u003evoid (*signal(int sig, void (*handler)(int))); Return previous signal disposition on success,or SIG_ERR on error handler可以用以下的值取代 SIG_DFL:將訊號處置 重新設定為預設值，適用於還原先前signal()呼叫改變的訊號處置 SIG_IGN:忽略該訊號，行程也不會知道有此訊號 ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"訊號處理常式 範例： #include\u003csignal.h\u003e#include\"tlpi_hdr.h\" static void sigHandler(int sig) { printf(\"Ouch!\\n\"); } int main(int argc[], char *argv[]) { int j; if(signal(SIGINT, sigHandler) == SIG_ERR) errExit(\"signal\"); for(j = 0;;j++) { printf(\"%d\\n\", j); sleep(3); } } result: $ ./ouch 0 *Type Control-C* Ouch! 1 2 *Type Control-C* Ouch! 3 'Type Control-\\'(the terminal quit char) Quit(core dumped) ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"發送訊號 kill() #include\u003csignal.h\u003eint kill(pid_t pid, int sig); Return 0 on success, or -1 on error 若pid \u003e 0，會將訊號發給pid指定的行程 若pid == 0，會將訊號發送至與呼叫的行程同一個群組的每一個行程 若pid \u003c -1，在行程群組ID與pid絕對值相同的行程群組中的每個行程都會收到此訊號 若pid == -1，會將訊號發送到呼叫的行程有權將訊號送出的每個行程（不包含init，以及呼叫行程本身）。若特權級行程執行此呼叫，則系統上每個行程都會收到此訊號 要讓行程將訊號發送給另外一個行程需要的權限，規則如下： 特權級CAP_KILL行程可以發送訊號給任何行程 以root使用者身份與群組身份執行的init行程是一個特例，只能發送已安裝的處理常式之訊號，可以避免系統管理員意外殺死init行程。 SIGCONT，非特權行程可以將此訊號發送給相同作業階段（session）的任何其他行程，而不需理會使用者ID的檢查。此規則可以讓進行工作控制的shell重新啟動已停止的工作。 ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:5:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"其他發送訊號的方式：raise()、killpg() 發送訊號給自己 #include\u003csignal.h\u003eint raise(int sig); Returns 0 on success, or nonzero on error 等同於：kill(gitpid(), sig); 送出一個訊號給一個行程群組裡的每個成員 #include\u003csignal.h\u003eint killpg(pid_t pgrp, int sig); Return 0 on success, or -1 on error 等同於：kill(-pgrp, sig); ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:6:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"顯示訊號的說明 訊號的說明文字在sys_siglist陣列中，例如可以使用sys_siglist[SIGPIPE]，獲得訊號說明。但建議使用strsignal()函式。 #define _BSD_SOURCE #include\u003csignal.h\u003e extern const char *const sys_siglist[]; #define _GNU_SOURCE #include\u003cstring.h\u003echar *strsingnal(int sig); Returns pointer to signal description string 會檢查sig的邊界，並傳回一個指標指向該訊號的說明字串，若此訊號編號無效，就會指向錯誤字串 比起直接使用sys_siglist[] 的優點在於strsignal()是local-sensitive，因此訊號的說明會根據地域語言來呈現。 psignal()顯示msg參數所指的字串，後面接著一個冒號，如同strsignal()一樣，也是local-sensitive。 #include\u003csignal.h\u003evoid psignal(int sig, const char *msg); strsignal() psigna() sys_siglist並未納入SUSv3的標準中，但許多UNIX的系統有這些功能（SUSv4已納入） ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:7:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"訊號集(Signal Set) 可以使用一個singal set的資料結構表示多個訊號，型態為sigset_t ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:8:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"初始化訊號 sigemptyset()初始化成一個未包含任何成員的訊號集 sigfillset()初始化一個訊號集，使其包含全部的訊號 #include\u003csignal.h\u003e int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); Return 0 on success, or -1 on error 一定要用其中一個函式來初始化一個訊號集，因為C語言不會對automatic variable進行初始化 並且將靜態變數初始化為0的清空訊號集的方法不具可攜性，因此使用memset清空的方法也不可行 初始化之後，可以使用sigaddset()、sigdelset()將訊號添加或者刪除 #include\u003csignal.h\u003e int sigaddset(const sigset_t *sig, int sig); int sigdelset(const sigset_t *sig, int sig); Return 0 on success, or -1 on error 可以用sigismember()測試sig指定的訊號是否為set的成員 #include\u003csignal.h\u003eint sigismember(const sigset_t *set, int sig); Return 1 if sig is a member of set, 0 if it is not, or -1 on error GNU C 函式庫實作了三個非標準函式 #define _GNU_SOURCE #include\u003csignal.h\u003e int sigandset(sigset_t *dest, sigset_t *left, sigset_t *right); int sigorset(sigset_t *dest, sigset_t *left, sigset_t *right); Return 0 on success, or -1 on error int sigisemptyset(sigset_t *set); Return 1 if set is empty, otherwise 0 sigandset()將left和right sets 交集 存在dest set中 sigandset()將left和right sets 聯集 存在dest set中 若set內沒有signal則sigisemptyset return 1 ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:8:1","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"訊號遮罩(signal mask) kernel會為每個process維護一個singal mask，即一組傳遞給行程並會受到blocked的訊號，若將受到阻塞的訊號發送給行程，則訊號會被延遲傳遞，直到從行程的signal mask移除此訊號才會解除blocked。 可用下列方式將訊號新增到訊號遮罩： 當呼叫訊號處理常式，可以將觸發呼叫的訊號，自動新增到訊號遮罩中。 使用sigaction()，可以指定一組要阻塞的額外訊號，handler會將其阻塞 在任意時間點，sigprocmask()，直接將訊號新增(刪除)到signal mask #include\u003csignal.h\u003eint sigprocmask(int how, const sigset_t *set, sigset_t *oldset); Return 0 on success, or -1 on error how參數 SIG_BLOCK 會將mask設定為 現值ORset =\u003e 將set指向的signal set添加到mask中 SIG_UNBLOCK 將set指向的signal set從mask中刪除 SIG_SETMASK 給set指向的signal set設定 signal mask ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:9:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"擱置的訊號 (Pending Signal) 行程收到一個目前被blocked的訊號，會加入pending signal set，可以用sigpending()來獲得行程目前的擱置訊號 #include\u003csignal.h\u003eint sigpending(sigset_t *set); Return 0 on success, or -1 on error ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:10:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux"],"content":"等待訊號 pause() 會使process暫停執行，直到受到handler中斷為止，或是一個未經處理的訊號終止process #include\u003cunistd.h\u003e int pause(void); return -1 with errno set to EINTR ","date":"2021-05-29","objectID":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:11:0","tags":[],"title":"Linux Chapter 20 Signal 基本概念","uri":"/2021-05-29-linux_chapter_20_signal-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Linux_嵌入式開發"],"content":"Linux 嵌入式開發 – 並行開發— System V IPC ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:0:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"System V IPC 包含共享內存、消息對列、和信號燈集 每個IPC對象有唯一的ID IPC對象創建後一直存在，直到被顯式的刪除（主動刪除） 每個IPC對象有一個關聯的KEY ipcs / ipcrm 實現進程間通訊 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:1:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"Key ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:1:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"ftok #include\u003csys/types.h\u003e#include\u003csys/ipc.h\u003ekey_t ftok(const char *path,int proj_id); 成功時返回合法的key值，失敗時返回EOF path存在且可以被訪問文件的路徑 proj_id 用於生成key的數字，不能為0 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:1:2","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"範例 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003csys/types.h\u003e#include\u003csys/ipc.h\u003e#include\u003cunistd.h\u003e int main(int argc, char *argv[]) { key_t key; if((key = ftok(\".\",'a')) == -1) { perror(\"key\"); exit(-1); } } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:1:3","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"共享內存 是一種最高效的進程間通信方式，進程可以直接讀寫內存，而不需要任何數據的拷貝 在內核空間創建，可以被進程映射到用戶空間訪問，使用靈活 由於多個進程可以同時訪問共享內存，因此需要同步和互斥機制配合使用 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:2:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"使用步驟 創建/打開共享內存 映射共享內存，即把指定的共享內存映射到進程的地址空間用於訪問 讀寫共享內存 撤銷共享內存映射 刪除共享內存對象 創建 #include\u003csys/ipc.h\u003e#include\u003csys/shm.h\u003eint shmget(key_t key, int size, int shmflg); 成功時返回共享內存的id，失敗時返回EOF key和共享內存關聯的key, IPC_PRIVATE或ftok生成 shmflg共享內存標誌位 IPC_CREAT|0666 範例：創建一個私有的共享內存，大小為512 bytes,權限0666 int shmid; if((shmid = shmget(IPC_PRIVATE,512,0666)) \u003c 0) { perror(\"shmget\"); exit(-1); } 範例：創建/打開一個和key關聯的共享內存，大小為1024 bytes,權限0666 key_t key; int shmid; if((key = ftok(\".\",'m')) == -1) { perror(\"ftok\"); exit(-1); } if((shmid = shmget(key,1024,IPC_CREAT|0666)) \u003c 0) { perror(\"shmget\"); exit(-1); } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:2:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"共享內存映射 #include\u003csys/ipc.h\u003e#include\u003csys/shm.h\u003evoid *shmat(int shmid, const void *shmaddr, int shmflg); 成功時返回映射的地址，失敗返回(void*)-1 shmid 要映射的共享內存id shmaddr 映射後的地址，NULL表示由系統自動映射 shmflag 0 表示可讀寫，SHM_RDONLY表示只讀 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:3:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"範例 通過指針訪問共享內存，指針類型取決於共享內存中存放的數據類型 在共享內存中存放鍵盤輸入的字串 char *addr; int shmid; ...... if((addr = (char *)shmat(shmid,NULL,0)) == (char *) -1) { perror(\"shmat\"); exit(-1); } fgets(addr, N, stdin); .... ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:3:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"撤銷映射 #include\u003csys/ipc.h\u003e#include\u003csys/shm.h\u003eint shmdt(void *shmaddr); 成功返回0，失敗返回EOF 不使用共享內存時應即時撤銷映射 進程結束時自動撤銷 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:3:2","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"內存控制 #include\u003csys/ipc.h\u003e#include\u003csys/shm.h\u003eint shmctl(int shmid, int cmd, struct shmid_ds *buf); 成功返回0，失敗返回EOF shmid要操作的共享內存id cmd要執行的操作 IPC_STAT(獲取共享內存的屬性存於struct shmid_ds結構buf中) IPC_SET(設置) IPC_RMID(刪除共享內存ID) ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:3:3","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"注意事項 每個共享內存大小都有限制 ipcs -l cat /proc/sys/kernel/shmmax 共享內存刪除的時間點 shmctl(shmid, IPC_RMID, NULL)添加刪除標記 nattach變成0時真正刪除 所有映射都取消時刪除 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:3:4","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"消息隊列 system V IPC對象的一種 由消息隊列ID來唯一標示 可以按照類型來發送接收消息 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:4:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"使用步驟 打開創建 msgget 發送消息 msgsnd 接收消息 msgrcv 控制消息 msgctl 創建/打開 #include\u003csys/ipc.h\u003e#include\u003csys/msg.h\u003eint msgget(key_t key, int msgflg); 成功時返回消息隊列的id,失敗時返回EOF key 和消息隊列關聯的key IPC_PRIVATE或ftok msgflg標誌位 IPC_CREAT|0666 創建範例： #include\u003csys/ipc.h\u003e#include\u003csys/msg.h\u003eint main() { int msgid; key_t key; if((key = ftok(\".\",'q')) == -1) { perror(\"ftok\"); exit(-1); } if((msgid = msgget(key, IPC_CREAT|0666)) \u003c 0) { perror(\"msgget\"); exit(-1); } .... return 0; } 發送 #include\u003csys/ipc.h\u003e#include\u003csys/msg.h\u003eint msgsnd(int msgid,const void * msgp, size_t size, int msgflg); 成功時返回 0,失敗時返回 -1 msgp 消息緩衝區地址 size 消息正文長度 msgflg標誌位 0 或 IPC_NOWAIT 消息格式 通信雙方首先定義好統一的消息格式 用戶根據應用需求定義結構體類型 首（第一個）成員類型為long 代表消息類型（正整數） 其他成員都屬於消息正文 typedef struct { long mytype;//類型(首位) char mtext[64]; ... }MSG; 範例： typedef struct { long mytype;//類型(首位) char mtext[64]; }MSG; #define LEN(sizeof(MSG) - sizeof(long)) int main() { MSG buf; .... buf.mytype = 100; fgets(buf.mtext, 64, stdin); msgsnd(msgid, \u0026buf, LEN, 0); .... return 0; } 接收 #include\u003csys/ipc.h\u003e#include\u003csys/msg.h\u003eint msgrcv(int msgid,const void * msgp, size_t size, long msgtype, int msgflg); 成功時返回 0,失敗時返回 -1 msgp 消息緩衝區地址 size 消息正文長度 msgtype 指定接收消息的類型 msgflg標誌位 0 或 IPC_NOWAIT 範例： typedef struct { long mytype;//類型(首位) char mtext[64]; }MSG; #define LEN(sizeof(MSG) - sizeof(long)) int main() { MSG buf; .... if(msgrcv(msgid, \u0026buf, LEN, 200, 0) \u003c 0) { perror(\"msgrcv\"); exit(-1); } .... return 0; } 控制 #include\u003csys/ipc.h\u003e#include\u003csys/msg.h\u003eint msgctl(int msgid, int cmd, struct msqid_ds *buf); 成功時返回 0,失敗時返回 -1 cmd 要執行的操作 IPC_STAT/IPC_SET/IPC_RMID buf 存放隊列屬性的地址 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:4:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"練習 兩個進程通過消息隊列輪流將鍵盤輸入的字串發送給對方，接收並打印對方發送的消息 /*clientA.c*/ #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e#include\u003csys/type.h\u003e#include\u003csys/ipc.h\u003e#include\u003csys/msg.h\u003e typedef struct { long mytype; char mtext[64]; }MSG; #define LEN(sizeof(MSG) - sizeof(long)) #define TypeA 100 #define TypeB 200 int main() { key_t key; int msgid; MSG buf; if((key = ftok(\".\",'q')) == -1) { perror(\"ftok\"); exit(-1); } if((msgid = msgget(key, IPC_CREAT|0666)) \u003c 0) { perror(\"msgget\"); exit(-1); } while(1) { buf.mytpe = TypeB; printf(\"input \u003e \"); fgets(buf.mtext,64,stdin); msgsnd(msgid,\u0026buf, LEN, 0); if(strcmp(buf.mtext, \"quit\\n\")==0) break; if(msgrcv(msgid, \u0026buf, LEN, TypeA, 0) \u003c 0) { perror(\"msgrcv\"); exit(-1); } if(strcmp(buf.mtext, \"quit\\n\")==0) { msgctl(msgid, IPC_RMID, 0); exit(0); } printf(\"recv from clientB : %s\\n\",buf.mtext); } return 0; } /*clientB.c*/ #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e#include\u003csys/type.h\u003e#include\u003csys/ipc.h\u003e#include\u003csys/msg.h\u003e typedef struct { long mytype; char mtext[64]; }MSG; #define LEN(sizeof(MSG) - sizeof(long)) #define TypeA 100 #define TypeB 200 int main() { key_t key; int msgid; MSG buf; if((key = ftok(\".\",'q')) == -1) { perror(\"ftok\"); exit(-1); } if((msgid = msgget(key, IPC_CREAT|0666)) \u003c 0) { perror(\"msgget\"); exit(-1); } while(1) { if(msgrcv(msgid, \u0026buf, LEN, TypeB, 0) \u003c 0) { perror(\"msgrcv\"); exit(-1); } if(strcmp(buf.mtext, \"quit\\n\")==0) { msgctl(msgid,IPC_RMID,0); exit(0); } printf(\"recv from clientA : %s\\n\",buf.mtext); buf.mytpe = TypeA;//對方的類型 printf(\"input \u003e \"); fgets(buf.mtext,64,stdin); msgsnd(msgid,\u0026buf, LEN, 0); if(strcmp(buf.mtext, \"quit\\n\")==0) break; } return 0; } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:5:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"信號燈 也叫做信號量，用於進程或線程的同步或互斥機制 信號燈的類型 POSIX 無名信號燈 POSIX有名信號燈 system v 信號燈 信號燈代表資源的數量 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:6:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"特點 system V 信號燈是一個或多個信號燈的集合 可同時操作集合中多個信號燈 申請多個資源避免死鎖 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:6:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"使用步驟 打開/創建信號燈 semget 信號燈初始化 semctl P/V操作 semop 刪除信號燈 semctl 創建 #include\u003csys/ipc.h\u003e#inlcude\u003csys/sem.h\u003e int semget(key_t key, int nsems, int semflg); 成功時返回信號燈的id，失敗時返回-1 key 和消息隊列關聯的key IPC_PRIVATE或 ftok nsems 集合中包含計數信號燈的個數 semflg 標誌位 IPC_CREAT|0666 IPC_EXCL 初始化 #include\u003csys/ipc.h\u003e#inlcude\u003csys/sem.h\u003e int semctl(int semid, int semnum, int cmd,....); 成功時返回0，失敗時返回EOF semid 要操作的信號燈集 semnum 要操作的集合中的信號燈編號 cmd 執行的操作 SETVAL IPC_RMID union semun 取決於 cmd 範例： 假設信號燈集合中包含兩個信號燈，第一個初始化為2,第二個初始化0 union semun myun; myun.val = 2; if(semctl(semid, 0, SETVAL, myun) \u003c 0) { perror(\"semctl\"); exit(-1); } myun.val = 0; if(semctl(semid, 1, SETVAL, myun) \u003c 0) { perror(\"semctl\"); exit(-1); } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:6:2","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"信號燈P/V操作 #include\u003csys/ipc.h\u003e#inlcude\u003csys/sem.h\u003e int semop(int semid, struct sembuf *sops, unsigned nsops); 成功時返回0，失敗時返回EOF semid 要操作的信號燈集id sops 描述對信號燈操作的結構體（陣列） sembuf: 系統中已經定義 struct sembuf { short semnum; short sem_op; short sem_flg; }; semnum 信號燈編號 sem_op -1:P操作 1:V操作 sem_flg 0/IPC_NOWAIT 範例： 父子進程通過system V信號燈同步對共享內存的讀寫 父進程從鍵盤輸入字串到共享內存 子進程刪除字串中的空格並打印 父進程輸入quit後刪除共享內存的信號燈集，程序結束 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e#include\u003cstring.h\u003e#include\u003csignal.h\u003e#include\u003csignal.h\u003e#include\u003csys/types.h\u003e#include\u003csys/ipc.h\u003e#include\u003csys/shm.h\u003e#include\u003csys/sem.h\u003e #define N 64 #define READ 0 #define WRITE 1 union semun { int val; struct semid_ds *buf; unsigned short *array; struct seminfo *__buf; }; void init_sem(int semid, int s[], int n) { int i; union semun myun; for(i = 0;i \u003c n; i++) { myun.val = s[i]; semctl(semid, i, SETVAL, myun); } } void pv(int semid, int num, int op) { struct sembuf buf; buf.sem_num = num; buf.sem_op = op; buf.sem_flg = 0; semop(semid, \u0026buf, 1); } int main() { int shmid, semid, s[]={0,1}; pid_t pid; key_t key; char *shmaddr; if((key = ftok(\".\",'s')) == -1) { perror(\"ftok\"); exit(-1); } if((shmid = shmget(key, N, IPC_CREAT|0666)) \u003c 0) { perror(\"shmget\"); exit(-1); } if((semid = semget(key, 2, IPC_CREAT|0666)) \u003c 0) { perror(\"shmget\"); goto _error1; } init_sem(semid, s, 2); if((shmaddr = (char *)shmat(shmid, NULL,0)) == (char *) -1) { perror(\"shmat\"); goto _error2; } //create child process if((pid = fork()) \u003c 0) { perror(\"fork\"); goto _error2; } else if(pid == 0) { char *p,*q; while(1) { pv(semid, READ, -1); p = q = shmaddr; while(*q) { if(*q != ' ' ) { *p++ = *q; } q++; } *p = '\\0'; printf(\"%s\",shmaddr); pv(semid, WRITE,1); } } else { while(1) { pv(semid, WRITE, -1); printf(\"input \u003e \"); fgets(shmaddr, N,stdin); if(strcmp(shmaddr, \"quit\\n\") == 0) break; pv(semid,READ,1); } kill(pid, SIGUSR1); } _error2: semctl(semid, 0, IPC_RMID); _error1: shmctl(shmid,IPC_RMID,NULL); return 0; } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/:7:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—SystemV IPC","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-system-v-ipc/"},{"categories":["Linux_嵌入式開發"],"content":"Linux 嵌入式開發 – 並行開發— Unix進程間的通訊方式 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:0:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"Process間通訊介紹 早期： pipe fifo signal System V IPC share memory message queue semphore set —————————本地通信↑ —————————本地/網路通信↓ Linux socket ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:1:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"無名管道 只能用於有親緣關係的進程之間的通信 單工的通信模式，具有固定的讀端和寫端 創建時返回兩個文件描述符，分別用於讀寫管道 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:2:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"創建 - pipe #include\u003cunistd.h\u003eint pipe(int pfd[2]); 成功時返回0，失敗時返回EOF pfd 包含兩個元素的int 陣列，用來保存文件描述符 pfd[0]用於read管道，pfd[1]用於write管道 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:2:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"範例 子進程1和2分別往管道寫入字串，父進程讀管道內容並打印 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e#include\u003csys/types.h\u003e int main() { pid_t pid1, pid2; // save return value of fork() char buf[32]; int pfd[2]; if(pipe(pfd)\u003c0) { perror(\"pipe\"); exit(-1); } if((pid1 == fork()) \u003c 0 ) { perror(\"fork\"); exit(-1); } else if(pid1 == 0) // child process1 { strcpy(buf,\"process1\"); write(pfd[1],buf,32); exit(0); } else // parents process { if((pid2 = fork()) \u003c 0) { perror(\"fork\"); exit(-1); } else if(pid == 0) // child process 2 { sleep(1); strcpy(buf,\"process2\"); write(pfd[1],buf,32); } else { wait(NULL); read(pfd[0],buf,32); printf(\"%s\\n\",buf); wait(NULL); read(pfd[0],buf,32); printf(\"%s\\n\",buf); } } return 0; } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:2:2","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"讀無名管道 寫端存在 管道中有數據 read返回實際讀取的byte數 管道中無數據 進程read阻塞 寫端不存在 管道中有數據 read返回實際讀取的byte數 管道中無數據 read返回0 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:3:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"寫無名管道 讀端存在 管道中有空間 write返回實際寫入的byte數 管道中無空間 不保證原子操作（有多少空間先寫多少空間）進程寫阻塞 讀端不存在 管道中有空間 管道中無數據 會發生管道斷裂（被信號結束） 無名管道的大小獲取 #include\u003cstdio.h\u003e#include\u003cunistd.h\u003e#include\u003cstdlib.h\u003e int main() { int count = 0, pfd[2]; char buf[1024]; if(pipe(pfd) \u003c 0) { perror(\"pipe\"); exit(-1); } while(1) { write(pfd[1],buf,1024); printf(\"wrote %dk bytes\\n\",++count); } return 0; } 測試管道斷裂 – pipe_broken #include\u003cstdio.h\u003e#include\u003cunistd.h\u003e#include\u003cstdlib.h\u003e#include\u003csys/wait.h\u003e int main() { pid_t pid; int pfd[2],status; char buf[32]; if(pipe(pfd) \u003c 0) { perror(\"pipe\"); exit(-1); } close(pfd[0]); // close read if((pid = fork()) \u003c 0) { perror(\"fork\"); exit(-1); } else if(pid == 0) { write(pfd[1], buf, 32); exit(0); } else { wait(\u0026status); printf(\"status = %x \\n\",status); } return 0; } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:4:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"有名管道 對應管道文件，可以用於任意進程之間進行通信 打開管道時可以指定讀寫方式 透過文件I/O操作，內容存放在內存中 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:5:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"創建 #include\u003cunistd.h\u003e#include\u003cfcntl.h\u003eint mkfifo(const char *path, mode_t mode); 成功返回0，失敗返回EOF mode管道文件的權限 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:5:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"範例 ProcessA:循環從鍵盤輸入並寫入有名管道，quit時退出 ProcessB:循環統計processA每次寫入管道的字串長度 /* create_fifo.c */ #include\u003cunistd.h\u003e#include\u003cfcntl.h\u003e#include\u003cstdlib.h\u003e int main() { if(mkfifo(\"myfifo\",0666) \u003c 0) { perror(\"mkfifo\"); exit(-1); } return 0; } /* write_fifo.c*/ #include\u003cstdio.h\u003e#include\u003cunistd.h\u003e#include\u003cfcntl.h\u003e#include\u003cstdlib.h\u003e #define N 32 int main() { char buf[N]; int pfd; if(pfd = open(\"myfifo\",O_WRONLY)) \u003c 0) { perror(\"open\"); exit(-1); } while(1) { fgets(buf,N,stdin); if(strcmp(buf,\"quit\\n\") == 0) break; write(pfd,buf,N); } close(pfd); return 0; } /*read_fifo.c*/ #include\u003cstdio.h\u003e#include\u003cunistd.h\u003e#include\u003cfcntl.h\u003e#include\u003cstdlib.h\u003e #define N 32 int main() { char buf[N]; int pfd; if(pfd = open(\"myfifo\",O_WRONLY)) \u003c 0) { perror(\"open\"); exit(-1); } while(read(pfd,buf,N) \u003e 0) { printf(\"the length of string is %d\\n\",strlen(buf)); } close(pfd); return 0; } $ gcc -o create_fifo create_fifo.c $ gcc -o write_fifo write_fifo.c $ gcc -o read_fifo read_fifo.c $ ./create_fifo $ ll $ ./read_fifo $ ./write_fifo 有名管道可能會阻塞 – 當只有寫端或讀端其中一個開啟時會阻塞，只有當兩個端同時開啟open才會繼續運行 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:5:2","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"信號 在軟體層次上對中隊機制的一種模擬，是一種異步通信方式 linux kernal 通過信號通知user process，不同的信號代表不同的事件 process 對信號有不同的響應方式 缺省方式 忽略信號 捕捉信號（註冊信號） 常用信號： 信號相關命令 kill[-signal] pid 默認發送SIGTERM -sig 可指定信號 pid指定發送對象 killall[-u user | prog] prog 指定進程名 user指定用戶名 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:6:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"信號發送 #include\u003cunistd.h\u003e#include\u003csignal.h\u003eint kill(pid_t pid, int sig); int raise(int sig); // 給自己發信號 pid接收進程的進程號，0代表同組進程，-1代表所有進程 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:7:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"信號相關函數 /*定時器*/ int alarm(unsigned int seconds); 成功時返回上個定時器的剩餘時間 seconds定時器的時間，0取消定時器 一個進程中只能設定一個定時器，時間到會產生SIGALRM int pause(void); 進程一直阻塞，直到被信號中斷 被信號中斷後返回-1，errno為EINTR ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:8:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"範例 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003eint main() { alarm(3); pause(); printf(\"I have been waken up\\n\"); return 0; } 收到定時器signal時，進程就終止，因此不會打印line 8 $ a.out Alarm clock alarm常用於超時檢測 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:8:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"設置信號的響應方式 #include\u003cunistd.h\u003e#include\u003csignal.h\u003evoid(* signal(int signo,void(*handler)(int)))(int); 成功返回原先信號處理函數 signo要設置的信號類型 handler指定的信號處理函數：SIG_DFL代表缺省方式 ,SIG_IGN代表忽略信號 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:9:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"範例 #include\u003cunistd.h\u003e#include\u003csignal.h\u003e void handler(int signo) { if(signo == SIGINT) printf(\"I have got SIGINT\\n\"); if(signo == SIGQUIT) printf(\"I have got SIGINT\\n\"); } int main() { signal(SIGINT,hardler); signal(SIGQUIT,handler); while(1) pause(); return 0; } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/:9:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—Unix進程間的通訊方式","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC-unix%E9%80%B2%E7%A8%8B%E9%96%93%E7%9A%84%E9%80%9A%E8%A8%8A%E6%96%B9%E5%BC%8F/"},{"categories":["Linux_嵌入式開發"],"content":"Linux 嵌入式開發 – 並行開發—進程與線程 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:0:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Process概念 program 存放在disk上的指令和數據的有序集合（文件） 靜態的 process 執行一個program所分配的資源總稱 是program一次執行的總稱 動態的，包括創建，調度，執行，死亡 有獨立的地址空間 linux為每個進程創建task_struct ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:1:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Process 內容 process - | 正文段 |——– ——— | 用戶數據段 |—-program ——— | 系統數據段 | ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:2:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Process control block PID process user process status / priority file description table ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:3:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Process 類型 交互進程：在shell下啟動，可在前臺/後台運行 批處理進程：和在終端無關，被提交到一個作業隊列中以便順序執行 守護進程：和終端無關，一直在後台運行 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:4:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Process status running / ready waiting interrupt not interrupt terminated : 收到signal後可以繼續運行 zombie ： pcb沒有被釋放 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:5:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Thread process在切換時系統開銷大 同一個process中的thread共享相同的空間 Linux 不區分thread process ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:6:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"特點 通常thread指的是共享地址空間的多個任務 大大提高了任務切換的效率 避免額外的TLB \u0026 cache的刷新 thread共享： 可執行的命令 靜態資料 進程中打開的file descriptor 當前工作目錄 user id user group id thread私有： tid pc \u0026 相關暫存器 stack \u0026 heap errno priority 執行狀態和屬性 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:6:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Linux thread lib pthread提供如下基本操作 創建 回收 結束 同步和互斥機制 信號量 互斥鎖 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:7:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"創建 #include\u003cpthread.h\u003eint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*routine)(void *), void *arg); thread 線程對象 attr 線程屬性，NULL表示默認 routine線程執行的函數 arg 傳遞給routine的參數 成功返回0 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:7:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"回收 #include\u003cpthread.h\u003eint pthread_join(pthread_t thread, void **retval); thread要回收的對象 調用thread阻塞直到thread結束 *retval接收thread 的返回值 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:7:2","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"結束 #include\u003cpthread.h\u003eint pthread_exit(void *retval); 結束當前線程 retval可以被其他thread通過pthread_join獲取 thread私有資源將被釋放 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:7:3","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"範例 /*thread_demo.c*/ #include\u003cpthread.h\u003e#include\u003cstdio.h\u003e#include\u003cstring.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e char msg[32] = \"Hello World\"; void *thread_func(void *arg) { sleep(1); strcpy(msg, \"mark by thread\"); pthread_exit(\"3Q for waiting for me\"); } int main(void) { pthread_t a_thread; void *result; if(pthread_create(\u0026a_thread,NULL,thread_func,NULL)!=0){ printf(\"fail to pthread_create\"); exit(-1); } pthread_join(a_thread, \u0026result); printf(\"result is %s\\n\",result); printf(\"msg is %s\\n\",msg); return 0; } 編譯：gcc -o thread_demo thread_demo.c -lpthread $ ./thread_demo result is 3Q for waiting for me msg is mark by thread ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:7:4","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"Thread通信 – 同步synchronization 由信號量來決定線程是繼續運行還是阻塞 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:8:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"信號量 信號量代表某一類資源，其值表示系統中該資源的數量 是一個受保護的變數，只能通過三種操作來訪問 初始化 P操作（申請資源） V操作（釋放資源）=\u003e 一定會阻塞 P/V操作 P(S)： if(信號量\u003e0){ 申請資源的任務繼續運行; 信號量的值減1; } else{ 申請資源的任務阻塞 }; V(S): 信號值加一 if(有任務在等待資源){ 喚醒等待的任務，讓其讓其繼續運行 } Posix 信號量 posix有兩種信號量 無名信號量（基於memory的信號量）=\u003e 用於線程 有名信號量 =\u003e 可用於線程或是進程 pthread庫常用的信號量操作函數： int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_wait(sem_t *sem); // P操作 int sem_post(sem_t *sem); // V操作 初始化 #include\u003csemaphore.h\u003eint sem_init(sem_t *sem, int pshared, unsigned int value); 成功返回0,失敗時EOF sem指向要初始化的信號量對象 pshared 0-thread間，1-process間 val信號量初值 P/V操作 #include\u003csemaphore.h\u003eint sem_wait(sem_t *sem); // P操作 int sem_post(sem_t *sem); // V操作 成功返回0,失敗時EOF sem指向要初始化的信號量對象 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:8:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"線程同步–範例一 兩個線程同步讀寫緩衝區（生產者與消費者問題） /*不嚴謹*/ #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e#include\u003csemaphore.h\u003e#include\u003cstring.h\u003e char buf[32]; sem_t sem; void *function(void *arg); int main(void) { pthread_t a_thread; if(sem_init(\u0026sem,0,0)\u003c0){ perror(\"sem_init\"); exit(-1); } if(pthread_create(\u0026a_thread,NULL,function,NULL)!=0){ printf(\"fail\\n\"); exit(-1); } printf(\"input 'quit'to exit\\n\"); do{ //stdin write fgets(buf,32,stdin); sem_post(\u0026sem); }while(strncmp(buf,\"quit\",4)!=0); return 0; } void *function(void *arg)//read { while(1) { sem_wait(\u0026sem); printf(\"you enter %d characters\\n\",strlen(buf)); } } /*嚴謹*/ #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e#include\u003csemaphore.h\u003e#include\u003cstring.h\u003e char buf[32]; sem_t sem_r,sem_w; void *function(void *arg); int main(void) { pthread_t a_thread; if(sem_init(\u0026sem_r,0,0)\u003c0){ perror(\"sem_init\"); exit(-1); } if(sem_init(\u0026sem_w,0,1)\u003c0){ perror(\"sem_init\"); exit(-1); } if(pthread_create(\u0026a_thread,NULL,function,NULL)!=0){ printf(\"fail\\n\"); exit(-1); } printf(\"input 'quit'to exit\\n\"); do{ //stdin write sem_wait(\u0026sem_w); fgets(buf,32,stdin); sem_post(\u0026sem_r); }while(strncmp(buf,\"quit\",4)!=0); return 0; } void *function(void *arg)//read { while(1) { sem_wait(\u0026sem_r); printf(\"you enter %d characters\\n\",strlen(buf)); sem_post(\u0026sem_w); } } ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:9:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"互斥 臨界資源 （共享資源） 一次只允許一個任務（進程、線程）訪問的共享資源 臨界區 訪問臨界資源的code 互斥機制 mutex互斥鎖 任務訪問臨界資源前，申請鎖，訪問完後釋放鎖 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:10:0","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"互斥鎖初始化 #include\u003cpthread.h\u003eint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * attr); 成功時返回0，失敗返回錯誤 mutex指向要初始化的互斥鎖對象 attr互斥鎖屬性，NULL表示缺少屬性 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:10:1","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"申請鎖 #include\u003cpthread.h\u003eint pthread_mutex_lock(pthread_mutex_t *mutex); 成功時返回0，失敗返回錯誤 mutex指向要初始化的互斥鎖對象 如果無法獲得鎖，任務阻塞 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:10:2","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"釋放鎖 #include\u003cpthread.h\u003eint pthread_mutex_unlock(pthread_mutex_t *mutex); 成功時返回0，失敗返回錯誤 mutex指向要初始化的互斥鎖對象 執行完臨界區必須即時釋放鎖 ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:10:3","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux_嵌入式開發"],"content":"範例 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cunistd.h\u003e#include\u003cpthread.h\u003e#include\u003cstring.h\u003e#define _LOCK_ unsigned int count, value1,value2; pthread_mutex_t lock; void *func(void *arg); int main(){ pthread_t a_thread; if(pthread_mutex_init(\u0026lock, NULL) != 0){ printf(\"fail to pthread init\\n\"); exit(-1); } if(pthread_create(\u0026a_thread,NULL,func,NULL)!=0) { printf(\"fail to pthread create\"); exit(-1); } while(1){ count++; #ifdef _LOCK_ pthread_mutex_lock(\u0026lock); #endif value1 = count; value2 = count; #ifdef _LOCK_ pthread_mutex_unlock(\u0026lock); #endif } return 0; } void *func(void *arg) { while(1) { count++; #ifdef _LOCK_ pthread_mutex_lock(\u0026lock); #endif if(value1 != value2) { printf(\"value1 = %u,value2 = %u\\n\",value1,value2); usleep(1000000); } #ifdef _LOCK_ pthread_mutex_unlock(\u0026lock); #endif } } 編譯： 使用互斥鎖 gcc -o test test.c -lpthread -D_LOCK_ 不使用互斥鎖 gcc -o test test.c -lpthread ","date":"2021-05-20","objectID":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/:10:4","tags":[],"title":"Linux 嵌入式開發 – 並行開發—進程與線程","uri":"/2021-05-20-linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%96%8B%E7%99%BC-%E4%B8%A6%E8%A1%8C%E9%96%8B%E7%99%BC%E9%80%B2%E7%A8%8B%E8%88%87%E7%B7%9A%E7%A8%8B/"},{"categories":["Linux"],"content":"檔案I/O緩衝區 The Linux programming interface chapter 13 ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:0:0","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"核心緩衝區概述 system call read() \u0026 write()在操作磁碟檔案時不會直接對磁碟存取，而是單純在使用者空間緩衝區與核心緩衝區快取（kernel buffer cache）之間複製資料。 例如： write(fd, \"abc\",3) 在後續的某個時間點，核心會將其緩衝區的資料寫入磁碟 如果在此期間，另外一個process試圖讀取檔案的這幾個bytes，則核心將自動從緩衝區提供資料，而不是從檔案讀取。同理於read()期間有write() process的情況 ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:1:0","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"緩衝區大小對效能的影響 system cpu time：主要是測量使用者空間與核心空間之間資料傳輸所消耗的時間 包含CPU的處理, 等待I/O I/O的處理,作業系統處理提供一些服務額外的時間，以及系統閒置的時間 Elapsed time : 完整的程式在這個系統裡面執行的時間 當緩衝區大小為1byte，需要呼叫大約一億次的system call，而緩衝區大小為4096bytes時，system call次數約為24000，當超過此設定值，效能的改善就開始不明顯，是因為在使用者空間和核心空間之間複製資料以及執行實際I/O所需的時間相較之下，read()和write()的system call 成本就顯得微不足道。 ＊ 結論： 若我們正對檔案進行大量的資料讀寫，則以大區塊緩衝資料來減少system call 即可提升系統效能 ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:2:0","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"stdio函式庫的緩衝 操作磁碟檔案時，對大型區塊資料使用緩衝可以降低system call。 ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:3:0","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"設定一個stdio stream的緩衝模式 #include\u003cstdio.h\u003eint setvbuf(FILE *stream, char *buf, int mode, size_t size); 在開啟串流之後，必須在對串流進行任何其他的stdio函式之前先呼叫setbuf() 因為setbuf()將影響後續的stdio操作對串流的行為 參數 stream:可以識別要修改的檔案stream緩衝區 buf \u0026 size 指定使用的緩衝區 若buf不為NULL則以其指向的size大小區塊作為stream的緩衝區，因為stdio接著會使用buf指向的緩衝區，所以應該以靜態配置或使用malloc()於heap做動態配置，不應該配置為stack裡面的區域變數，否則當函式返回時會釋放stack frame，導致混亂 若buf為NULL，stdio會自動配置一個緩衝區提供stream使用（除非我們選擇無緩衝的I/O)。在SUSv3允許但不要求實作時使用size來決定緩衝區的大小 mode指定緩衝區的類型 ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:3:1","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"範例 #defind BUF_SIZE 1024 static char buf[BUF_SIZE]; if(setvbuf(stdout, buf, _IOFBF) != 0) errexit(\"setbuf\"); ＊setvbuf()出錯時會傳回非0值 setbuf()位於setvbuf上層 #include\u003cstdio.h\u003evoid setbuf(FILE *stream, char *buf); 呼叫setbuf(fp,buf)等同於setvbuf(fp, buf, (buf != NULL) ? _IOFBF: _IONBF, BUFSIZ); 參數 buf可以指定為NULL表示無緩衝，或指向由呼叫者配置的BUFSIZ大小的緩衝區（BUFSIZ定義在\u003cstdio.h\u003e通常是8192） setbuffer()與setbuf()相似，但允許呼叫者指定buf緩衝區的大小 #define _BSD_SOURCE #include\u003cstdio.h\u003evoid setbuffer(FILE *stream, char *buf, size_t size); SUSv3並未規範此函式，但多數UNIX有提供 ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:3:2","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"刷新stdio緩衝區 我們可以用fflush()函式強制寫入stdio的輸出串流資料（如透過write()刷新寫入核心緩衝區）。此函式會刷新指定stream的輸出緩衝區 #include\u003cstdio.h\u003eint fflush(FILE *stream); 參數 若stream為NULL，則fflush將刷新與output stream相關的每個stdio緩衝區 也能應用於輸入串流，這將捨棄緩衝區裡面的所有輸入資料（當程序下次嘗試從串流讀資料，將重頭開始寫入緩衝區） 當關閉對應的串流時，會自動刷新stdio的緩衝區 在許多c函式庫實作中，若stdin stdout是參考到terminal，則從stdin讀取輸入時，都會進行一次fflush(stdout)呼叫，效果是刷新寫入stdout的任何提示，但不包含結尾的換行符號 範例1: #include\u003cstdio.h\u003eint main() { printf(\"hello\"); fflush();//fflush(stdout); return 0; } 常用於立刻將輸入值印出來。 範例2： #include\u003cstdio.h\u003eint main() { int i; while(1) { printf(\"Enter a integer:\"); scanf(\"%d\",\u0026i); printf(\"%d\\n\",i); } return 0; } 此範例如果輸入非int類型的值，則輸入值會放入緩衝區，而導致你下個迴圈的輸入無法被讀到，因為scanf會一直去緩衝區讀取，而不會理會使用者輸入。可以在scanf()前面加上，fflush(stdin)，但不是每個系統都有支援fflush(stdin)。這時候可以利用一些特殊的函數（內部本身就包含fflush()），來解決這種問題。 ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:3:3","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"控制檔案I/O的核心緩衝 可以強制將核心緩衝區刷新到輸出檔，例如資料庫的日誌行程，要確保在繼續操作前將結果真正的寫入到硬碟（或硬碟的快取） 同步I/O資料完整性與同步I/O檔案完整性 SUSv3將同步I/O完成(synchronized IO completion) 定義為： 一種I/O操作，若非已成功傳輸（到硬碟），及診斷為同步失敗 有兩種不同類型的同步I/O完成 synchronized I/O data integrity completion(資料完整性) 對於read操作，意思是所需的檔案已經（從硬碟）傳輸給process。若有任何未完成的write操作並且會影響資料的read時，會在進行read前，將資料寫入磁碟 對於write操作，意思是在write請求的指定資料已經傳輸（到硬碟）完成，而且用以取得資料所需的全部檔案中的中繼資料也已經全部傳輸（到硬碟）完成。 關鍵在於不需要將全部的已修改檔案中的中繼資料屬性傳輸完成，就可以檢索檔案資料 需要傳輸的其中一個中繼資料屬性是檔案的大小 synchronized I/O file integrity compliction(檔案完整性) 與資料完整性的差異在於，在檔案更新期間，會將全部已更新的檔案中繼資料傳輸到硬碟，即使後續的檔案read操作不需要檔案中繼資料 中繼資料（metadata）：檔案擁有者與所屬群組 檔案權限，檔案大小，檔案的（hard）連結數量，檔案最後的存取時間，最後修改時間，中繼資料發生變化的時間，檔案資料區塊指標 用於控制檔案I/O核心緩衝的系統呼叫 #include\u003cunistd.h\u003eint fsync(int fd); 成功返回0,失敗返回-1 將緩衝資料與開啟檔案的fd相關的metadate刷新到磁碟 會強制檔案處於I/O檔案完整性狀態 會在完成磁碟裝置（或快取記憶體）的傳輸之後才返回 #include\u003cunistd.h\u003eint fdatasync(int fd); 成功返回0,失敗返回-1 會強制檔案處於I/O資料完整性狀態 操作與fsync()類似 可能會降低磁碟操作的次數 #include\u003cunistd.h\u003evoid sync(int void); 會將包含更新檔案資訊的全部核心緩衝區（資料區塊，指標區塊，中繼資料等）刷新到磁碟 在已將全部資料傳輸到磁碟裝置（或者是快取）之後返回 在SUSv3中，實作時只是單純對I/O傳遞進行排班，因此可以在未完成之前返回 同步全部的寫入檔案 在呼叫open()時指定O_SYNC flag可以讓全部的後續輸出同步 fd = open(pathname,O_WRONLY | O_SYNC); 每次write()檔案都會自動將檔案資料與中繼資料刷新到硬碟（依照檔案完整性進行寫入操作） 關於O_SYNC對效能的影響可以參考 書籍p.265 I/O緩衝摘要 繞過緩衝區快取：直接I/O 在進行磁碟I/O時，繞過緩衝區快取，可以直接從使用者空間將資料傳輸到檔案或磁碟裝置。 direct I/O有時反而會大幅降低效能，因為核心為了改善效能，進行的許多優化。因此只適用於有特定I/O需求的應用，例如資料庫系統有自己的快取和I/O優化，所以不需要核心消耗CPU的時間與記憶體去進行同樣的工作。 可以對個別的檔案或block device進行直接I/O，可以在open()指定O_DIRECT flag。 direct I/O的對齊限制 傳虛用途的資料緩衝區，必須對齊符合block size倍數的記憶體邊界 資料傳輸的開始點，即檔案或裝置的偏移量，必須是block size的倍數 待傳輸資料的長度必須是block sizek的倍數 為檔案I/O混搭函式庫函式與system call #include\u003cstdio.h\u003eint filno(FILE *stream); Returns file descriptor on sucess, or -1 on error FILE *fdopen(int fd, const char *mode); Returns (new) file pointer on success, or NULL on error 對同一個檔案進行I/O操作時，可以混搭system call與標準C函式庫的函式 fdopen()是fileno()的反函式，此函式會建立一個與此檔案描述符對應的stream給I/O使用 fdopen()對非正規檔案的描述符特別有用，例如建立通訊（socket）和 pipe的system call ","date":"2021-05-20","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/:3:4","tags":[],"title":"Linux Chapter 13 - 檔案IO緩衝區","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E7%B7%A9%E8%A1%9D%E5%8D%80/"},{"categories":["Linux"],"content":"檔案I/O深入探討 ","date":"0001-01-01","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E/:0:0","tags":[],"title":"Linux Chapter 5 - 檔案IO深入探討","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E/"},{"categories":["Linux"],"content":"原子與競速條件 以互斥的方式建立檔案 在open()中設定O_EXCL與O_CREAT可以在檔案已存在的時候回傳錯誤，確保process本身是檔案的建立者 將資料附加到檔案 當我們有多個process要增加資料到同一個檔案 會有下列這種寫法 if(lseek(fd,0,SEEK_END)==-1) errExit(\"lseek\"); if(write(fd, buf, len)!=len) fatal(\"Partial/failed write\"); 會有race condtion問題，第一個process在lseek()與write()之間被第二個相同的行程中斷，那兩個行程會在寫入之前將他們的file offset設定到相同位置，因此會產生互相覆蓋的現象 為了避免此問題，必須讓移往檔案結尾下一個byte操作與寫入操作都是原子操作，我們可以使用O_APPENDflag達成 ","date":"0001-01-01","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E/:1:0","tags":[],"title":"Linux Chapter 5 - 檔案IO深入探討","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E/"},{"categories":["Linux"],"content":"檔案操作控制 #include\u003cfcntl.h\u003eint fcntl(int fd, int cmd,...); Return value on success depends on cmd, returns -1 on error 用途之一是用來取得或修改access mode,以及一個開啟檔案的開啟檔案狀態flag 取得設定的cmd : F_GETFL int flags, accessMode; flags = fcntl(fd, F_GETFL); if(flags == -1) errExit(\"fcntl\"); 可以使用 \u0026 操作去判斷目前的開啟檔案狀態flag if(flags \u0026 O_SYNC) printf(\"write are synchronized\\n\"); 若要檢查檔案的access mode,必須使用如下的操作 accessMode = flags \u0026 O_ACCMODE; if(accessMode == O_WRONLY || accessMode == O_RDWR) printf(\"file is writable\\n\"); 詳細的原因可以參考書p.104 修改開啟檔案狀態flag int flags; flags = fcntl(fd, F_GETFL); if(flags == -1) errExit(\"fcntl\"); flags |= O_APPEND; //新增一個新的狀態flag if(fcntl(fd, F_SETFL,flags) == -1) //更新狀態 errExit(\"fcntl\"); ","date":"0001-01-01","objectID":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E/:2:0","tags":[],"title":"Linux Chapter 5 - 檔案IO深入探討","uri":"/2021-05-20-%E6%AA%94%E6%A1%88i_o%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E/"},{"categories":["Linux"],"content":"檔案I/O 概述 全部執行I/O的系統呼叫都是透過檔案描述符來控制開啟的檔案，各類型的檔案在開啟之後，都能以檔案描述符進行操控。 ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:0","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"標準檔案符 shell平時會將以下三個檔案描述符保持一直開啟，可以使用I/O redirection進行適當的修改 file descriptor 用途 POSIX 名稱 stdio stream 0 標準輸入 STDIN_FILENO stdin 1 標準輸出 STDOUT_FILENO stdout 2 標準錯誤 STDERR_FILENO stderr ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:1","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"開啟檔案 open() #include\u003csys/stat.h\u003e#include\u003cfcntl.h\u003eint open(const char *pathname, int flags, ... /*mode_t mode*/); Return file descriptor on success, -1 on error flags -\u003e 為位元mask 指定檔案的存取模式 mode -\u003e 指定了檔案的存取權限（如果open()沒有指定O_CTEATflags可以省略） 由於flags各個參數互相獨立（除了必選項不可重複）皆可以使用|來新增性質 必選項：以下三個常數中必須指定一個，且僅允許指定一個。 flags 用途 O_RDONLY 以唯讀模式開啟 O_WRONLY 以唯寫模式開啟 O_RDWR 以讀寫模式開啟 以可讀寫方式打開文件。上述三種旗標是互斥的，也就是不可同時使用，但可與下列的旗標利用OR(|)運算符組合。 以下可選項可以同時指定0個或多個，和必選項按位|起來作為flags參數。 flags 用途 O_CLOEXEC 設定close-on-exec flags O_CREAT 若檔案不存在則建立 O_DIRECTORY 如果pathname不是目錄，失敗 O_EXCL 結合O_CREAT參數使用，專門用來建立檔案，若創建文件時，文件已存在，會返回錯誤訊息 O_LARGEFILE 在32位元系統中使用，可以開啟大檔案 O_NOCTTY 不要讓pathname所指向的終端設備，成為控制終端機 O_NOFOLLOW 如果參數pathname 所指的文件為一符號連接，則會令打開文件失敗 O_TRUNC 若文件存在並且以可寫的方式打開時，此旗標會令文件長度清為0，而原來存於該文件的資料也會消失。 O_APPEND 總在檔案結尾新增資料 O_ASYNC 進行I/O操作時，產生signal O_DIRECT 檔案I/O跳過 buffer cache O_DSYNC 提供同步I/O的資料完整性 O_NOATIME 在read()時不更新最近的存取時間 O_NONBLOCK 以非阻塞的方式開啟 O_SYNC 以同步的方式寫入檔案 詳細內容可以參考The linux programming interface 國際中文版p.84 man page : https://man7.org/linux/man-pages/man2/open.2.html ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:2","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"創建檔案 creat() 根據pathname建立並開啟一個檔案，若檔案存在=\u003e開啟並清空檔案內容 #include\u003cfcntl.h\u003eint creat(const char* pathname, mode_t mode); 可以等價於以下的open()函數 fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode); ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:3","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"讀取檔案 read() #include\u003cunist.h\u003essize_t read(int fd, void *buffer, size_t count); /*returns number of bytes read,0 on EOF,or -1 on error*/ count 指定最多可以讀取的byte數量 buffer 提供用來存放輸入資料的buffer cache位址 buffer cache至少有count個bytes man page : https://man7.org/linux/man-pages/man2/read.2.html ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:4","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"寫入檔案 write() #include\u003cunistd.h\u003essize_t write(int fd, const void *buffer, size_t count); Return number of bytes written, or -1 on error count 指定最多可以要從buffer寫入檔案的byte數量 buffer 要寫入檔案的資料bytes數 ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:5","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"關閉檔案 #include\u003cunistd.h\u003eint close(int fd); Return 0 on success, or -1 on error ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:6","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"改變檔案偏移量 有時候也稱為讀寫偏移量或指標。指的是執行下一個read() or write()操作的檔案位置。檔案開啟時或指向開頭（偏移量 = 0） 針對fd參數所代表的已開啟檔案，可以使用lseek() function #include\u003cunistd.h\u003eoff_t lseek(int fd,off_t offset, int whence); Return new file offset if successful, or -1 on error offset指定以byte為單位的數值,whence表示應參考哪個基準點來解釋offset參數，如下列表格 whence 用途 SEEK_SET 將檔案偏移量從檔案的起始點開始算 offset 個 bytes SEEK_CUR 相對於目前的偏移量，調整offset個 bytes SEEK_END 將檔案偏移量設定為檔案大小加上offset 個 bytes，可以說offset應從檔案最後一個byte之後的下一個byte開始算起 一些lseek()的應用案例 lseek(fd,0,SEEK_SET); /*Start of file*/ lseek(fd,0,SEEK_END); /*Next byte after the end of the file*/ lseek(fd,-1,SEEK_END); /*Last byte of file*/ lseek(fd,-10,SEEK_CUR); /*Ten bytes prior to current location*/ lseek(fd,10000,SEEK_END); /*10001 past last byte of file*/ lseek()不允許應用於pipe,FIFO,socket or terminal ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:7","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"},{"categories":["Linux"],"content":"檔案空洞(file hole) 如果檔案偏移量跨越了檔案結尾，然後再執行I/O操作，read()會return 0，但write()可以在檔案結尾後任意寫資料進去。 從檔案結尾之後到新寫入資料之間的這段空間就稱為檔案空洞。 檔案空洞不佔用任何空間，優勢在於相較於為實際需要的空bytes分配磁碟區塊，稀疏填充的檔案會佔用較少的空間。 以下為apue範例 #include \"apue.h\"#include \u003cfcntl.h\u003e char buf1[] = \"abcdefghij\"; char buf2[] = \"ABCDEFGHIJ\"; int main(void) { int fd; if ((fd = creat(\"file.hole\", FILE_MODE)) \u003c 0) err_sys(\"creat error\"); if (write(fd, buf1, 10) != 10) err_sys(\"buf1 write error\"); /* offset now = 10 */ if (lseek(fd, 16384, SEEK_SET) == -1) err_sys(\"lseek error\"); /* offset now = 16384 */ if (write(fd, buf2, 10) != 10) err_sys(\"buf2 write error\"); /* offset now = 16394 */ exit(0); } running result $ ./a.out $ ls -l file.hole -rw-r--r-- 1 sar 16394 \u003cdate\u003e file.hole $ od -c file.hole 0000000 a b c d e f g h i j \\0 \\0 \\0 \\0 \\0 \\0 0000020 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 * 0040000 A B C D E F G H I J 0040012 可以使用du -h 指令 =\u003e 顯示檔案佔用的block是多少 ","date":"2021-05-19","objectID":"/2021-05-19-%E6%AA%94%E6%A1%88io/:0:8","tags":[],"title":"Linux Chapter 4 - 檔案IO","uri":"/2021-05-19-%E6%AA%94%E6%A1%88io/"}]